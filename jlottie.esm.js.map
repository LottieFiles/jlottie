{"version":3,"file":"jlottie.esm.js","sources":["../src/jlottie.js"],"sourcesContent":["const xmlns = 'http://www.w3.org/2000/svg';\n\nvar animation = [];\nvar frame = [];\nvar animationCount = -1;\nvar animationLength = 0;\nvar animationLoading = 0;\nvar frozen = false;\nvar playStarted = false;\n\n///////////// BEZIER\n\nfunction bezierCurve(p1, c1, c2, p2, fromT, toT, isLayer, animationId, refKey, addTransformation, objectId, depth) {\n  var newNodes = [];\n\n  if (c1.hasOwnProperty('x')) {\n  } else {\n    if (c1.length >= 1) {\n      c1.x = c1[0];\n      if (refKey == 'p' || refKey == 's') {\n        c1.y = c1[1];\n      }\n    }\n  }\n  if (c2.hasOwnProperty('x')) {\n  } else {\n    if (c2.length >= 1) {\n      c2.x = c1[0];\n      if (refKey == 'p' || refKey == 's') {\n        c2.y = c1[1];\n      }\n    }\n  }\n  if (refKey == 's') {\n    if (c1.x.length > 1) {\n      c1.x = c1.x[0];\n      c1.y = c1.y[0];\n    }\n    if (c2.x.length > 1) {\n      c2.x = c2.x[0];\n      c2.y = c2.y[0];\n    }\n  }\n  var frames = toT - fromT;\n  var timeTick;\n  var oneMinusT;\n  var currentFrame = fromT;\n  for (var i = 1; i < frames; i++) {\n    timeTick = i / frames;\n    oneMinusT = 1 - timeTick;\n    newNodes.push({ _comp: 1, t: 0 });\n    currentFrame++;\n    newNodes[newNodes.length - 1]._frame = parseInt(currentFrame);\n    newNodes[newNodes.length - 1].t = parseInt(currentFrame);\n    newNodes[newNodes.length - 1].s = [];\n    if (refKey != 'ks') {\n      newNodes[newNodes.length - 1].s.push(\n        Math.pow(oneMinusT, 3) * p1[0] +\n          3 * Math.pow(oneMinusT, 2) * timeTick * (c1.x + p1[0]) +\n          3 * oneMinusT * Math.pow(timeTick, 2) * (c2.x + p2[0]) +\n          Math.pow(timeTick, 3) * p2[0],\n      );\n      if (refKey != 'x' && refKey != 'y') {\n        if (refKey == 'p' || refKey == 's') {\n          newNodes[newNodes.length - 1].s.push(\n            Math.pow(oneMinusT, 3) * p1[1] +\n              3 * Math.pow(oneMinusT, 2) * timeTick * (c1.y + p1[1]) +\n              3 * oneMinusT * Math.pow(timeTick, 2) * (c2.y + p2[1]) +\n              Math.pow(timeTick, 3) * p2[1],\n          );\n        }\n      }\n    } else {\n      newNodes[newNodes.length - 1].s.push({ i: [], o: [], v: [] });\n      var j = 0;\n      for (var k = 0; k < p1[j].i.length; k++) {\n        newNodes[newNodes.length - 1].s[newNodes[newNodes.length - 1].s.length - 1].i.push([\n          Math.pow(oneMinusT, 3) * p1[j].i[k][0] +\n            3 * Math.pow(oneMinusT, 2) * timeTick * (c1.x + p1[j].i[k][0]) +\n            3 * oneMinusT * Math.pow(timeTick, 2) * (c2.x + p2[j].i[k][0]) +\n            Math.pow(timeTick, 3) * p2[j].i[k][0],\n          Math.pow(oneMinusT, 3) * p1[j].i[k][1] +\n            3 * Math.pow(oneMinusT, 2) * timeTick * (c1.y + p1[j].i[k][1]) +\n            3 * oneMinusT * Math.pow(timeTick, 2) * (c2.y + p2[j].i[k][1]) +\n            Math.pow(timeTick, 3) * p2[j].i[k][1],\n        ]);\n\n        newNodes[newNodes.length - 1].s[newNodes[newNodes.length - 1].s.length - 1].o.push([\n          Math.pow(oneMinusT, 3) * p1[j].o[k][0] +\n            3 * Math.pow(oneMinusT, 2) * timeTick * (c1.x + p1[j].o[k][0]) +\n            3 * oneMinusT * Math.pow(timeTick, 2) * (c2.x + p2[j].o[k][0]) +\n            Math.pow(timeTick, 3) * p2[j].o[k][0],\n          Math.pow(oneMinusT, 3) * p1[j].o[k][1] +\n            3 * Math.pow(oneMinusT, 2) * timeTick * (c1.y + p1[j].o[k][1]) +\n            3 * oneMinusT * Math.pow(timeTick, 2) * (c2.y + p2[j].o[k][1]) +\n            Math.pow(timeTick, 3) * p2[j].o[k][1],\n        ]);\n\n        newNodes[newNodes.length - 1].s[newNodes[newNodes.length - 1].s.length - 1].v.push([\n          Math.pow(oneMinusT, 3) * p1[j].v[k][0] +\n            3 * Math.pow(oneMinusT, 2) * timeTick * (c1.x + p1[j].v[k][0]) +\n            3 * oneMinusT * Math.pow(timeTick, 2) * (c2.x + p2[j].v[k][0]) +\n            Math.pow(timeTick, 3) * p2[j].v[k][0],\n          Math.pow(oneMinusT, 3) * p1[j].v[k][1] +\n            3 * Math.pow(oneMinusT, 2) * timeTick * (c1.y + p1[j].v[k][1]) +\n            3 * oneMinusT * Math.pow(timeTick, 2) * (c2.y + p2[j].v[k][1]) +\n            Math.pow(timeTick, 3) * p2[j].v[k][1],\n        ]);\n      }\n    }\n    if (addTransformation && refKey != 'ks') {\n      addGroupPositionTransform(\n        currentFrame,\n        newNodes[newNodes.length - 1].s,\n        isLayer,\n        animationId,\n        refKey,\n        addTransformation,\n        objectId,\n        depth,\n      );\n    }\n  }\n\n  return newNodes;\n}\n\n///////////// CONTROL\n\nvar jlottie = {};\n\njlottie.destroy = function (name) {\n  if (animationCount < 0) {\n    return;\n  }\n  if (name === undefined) {\n    var elements = [];\n    for (var i = 0; i <= animationCount; i++) {\n      elements.push(animation[i]._elementId);\n    }\n    animation = [];\n    for (var i = 0; i <= elements; i++) {\n      document.getElementById(elements[i]).innerHTML = '';\n      animationCount = animationCount - 1;\n    }\n  } else {\n    name.toString();\n    name = name.replace(/#/g, '');\n    for (var i = 0; i <= animationCount; i++) {\n      if (animation[i]._elementId == name || animation[i]._customName == name) {\n        animation.splice(i, 1);\n        document.getElementById(name).innerHTML = '';\n        animationCount = animationCount - 1;\n        break;\n      }\n    }\n  }\n};\n\njlottie.play = function (name) {\n  if (animationCount < 0) {\n    return;\n  }\n  if (name === undefined) {\n    for (var i = 0; i <= animationCount; i++) {\n      animation[i]._paused = false;\n    }\n  } else {\n    name.toString();\n    name = name.replace(/#/g, '');\n    for (var i = 0; i <= animationCount; i++) {\n      if (animation[i]._elementId == name || animation[i]._customName == name) {\n        animation[i]._paused = false;\n        break;\n      }\n    }\n  }\n};\n\njlottie.stop = function (name) {\n  if (name === undefined) {\n    for (var i = 0; i <= animationCount; i++) {\n      animation[i]._paused = true;\n    }\n  } else {\n    name.toString();\n    name = name.replace(/#/g, '');\n    for (var i = 0; i < animationCount; i++) {\n      if (animation[i]._elementId == name || animation[i]._customName == name) {\n        animation[i]._paused = true;\n        break;\n      }\n    }\n  }\n};\n\njlottie.goToAndStop = function (_frame, isFrame, name) {\n  if (animationCount < 0) {\n    return;\n  }\n  if (name === undefined) {\n    console.log(animationCount);\n    for (var i = 0; i <= animationCount; i++) {\n      animation[i]._paused = true;\n      loadFrame(i, _frame);\n    }\n  } else {\n    name.toString();\n    name = name.replace(/#/g, '');\n    for (var i = 0; i <= animationCount; i++) {\n      if (animation[i]._elementId == name || animation[i]._customName == name) {\n        animation[i]._paused = true;\n        console.log(name + ' == ' + _frame);\n        loadFrame(i, _frame);\n        break;\n      }\n    }\n  }\n};\n\njlottie.loadAnimation = function (obj) {\n  if (obj.container === undefined && obj.path === undefined && obj.animationData === undefined) {\n    return;\n  }\n  var autoplay = true;\n  var loop = true;\n\n  if (!(obj.autoplay === undefined)) {\n    if (obj.autoplay === true || obj.autoplay === false) {\n      autoplay = obj.autoplay;\n    }\n  }\n\n  if (!(obj.loop === undefined)) {\n    if (obj.loop === true || obj.loop === false) {\n      loop = obj.loop;\n    }\n  }\n\n  if (!(obj.animationData === undefined) && obj.animationData.length > 0) {\n    animationCount = animationCount + 1;\n    var currentAnimation = animationCount;\n    animation[currentAnimation] = JSON.parse(http.responseText);\n    animation[currentAnimation]._elementId = elementId;\n    buildGraph(elementId, currentAnimation, obj.container, true, true);\n  } else {\n    if (!(obj.path === undefined) && obj.path) {\n      getJson(obj.path, '', '', '', '', '', obj.container, 0, obj.container.id, autoplay, loop);\n    }\n  }\n  if (!playStarted) {\n    playStarted = true;\n    window.requestAnimationFrame(lottiemate);\n  }\n};\n\n///////////// ANIMATOR\n\nfunction loadFrame(i, _currentFrame) {\n  for (var ref = 0; ref < animation[i]._refObj.length; ref++) {\n    var refObj = animation[i]._refObj[ref];\n    var nextObj = false;\n    for (var m = _currentFrame - 1; m >= 0; m--) {\n      for (var n = 0; n < animation[i]._scene[m]._transform.length; n++) {\n        if (animation[i]._scene[m]._transform[n].refObj == refObj) {\n          currentObj = document.getElementById(animation[i]._scene[m]._transform[n].refObj);\n          currentObjOther = document.getElementById(animation[i]._scene[m]._transform[n].refObjOther);\n          if (\n            animation[i]._scene[m]._transform[n].isTween ||\n            animation[i]._scene[m]._transform[n].combined.length > 0\n          ) {\n            if (animation[i]._scene[m]._transform[n].isTween) {\n              currentObj.setAttribute('d', animation[i]._scene[m]._transform[n].dataString);\n            }\n            currentObj.setAttribute('transform', animation[i]._scene[m]._transform[n].combined);\n            currentObjOther.setAttribute('opacity', animation[i]._scene[m]._transform[n].opacity);\n            nextObj = true;\n            break;\n          }\n        }\n        if (nextObj) break;\n      }\n      if (nextObj) continue;\n    }\n  }\n}\n\nfunction lottiemate() {\n  var currentDate = Date.now();\n  var currentObj;\n  for (var i = 0; i <= animationCount; i++) {\n    if (animation[i]._loaded && currentDate - animation[i]._lastTime >= animation[i]._frameTime) {\n      if (animation[i]._removed || animation[i]._paused) {\n        continue;\n      }\n      animation[i]._lastTime = currentDate;\n      animation[i]._currentFrame++;\n      if (animation[i]._currentFrame >= animation[i]._totalFrames) {\n        animation[i]._currentFrame = 0;\n        if (!animation[i]._loop) {\n          animation[i]._paused = true;\n          lottie.goToAndStop(animation[i]._totalFrames - 1, '', animation[i]._elementId);\n          continue;\n        }\n      }\n      for (var j = 0; j < animation[i]._scene[animation[i]._currentFrame]._transform.length; j++) {\n        if (animation[i]._scene[animation[i]._currentFrame]._transform[j].refObj.length > 0) {\n          currentObj = document.getElementById(animation[i]._scene[animation[i]._currentFrame]._transform[j].refObj);\n          currentObjOther = document.getElementById(\n            animation[i]._scene[animation[i]._currentFrame]._transform[j].refObjOther,\n          );\n          if (animation[i]._scene[animation[i]._currentFrame]._transform[j].isTween) {\n            currentObj.setAttribute('d', animation[i]._scene[animation[i]._currentFrame]._transform[j].dataString);\n          }\n          currentObj.setAttribute('transform', animation[i]._scene[animation[i]._currentFrame]._transform[j].combined);\n          currentObjOther.setAttribute(\n            'opacity',\n            animation[i]._scene[animation[i]._currentFrame]._transform[j].opacity,\n          );\n        }\n        if (animation[i]._scene[animation[i]._currentFrame]._transform[j].hide) {\n          document.getElementById(\n            animation[i]._scene[animation[i]._currentFrame]._transform[j].stageObj,\n          ).style.display = 'none';\n        }\n        if (animation[i]._scene[animation[i]._currentFrame]._transform[j].show) {\n          document.getElementById(\n            animation[i]._scene[animation[i]._currentFrame]._transform[j].stageObj,\n          ).style.display = 'block';\n        }\n      }\n    }\n  }\n  window.requestAnimationFrame(lottiemate);\n}\n\n///////////// BUILD SCENE GRAPH\nvar lastRefObj;\n\nfunction getEmptyTransform() {\n  var transforms = {};\n  transforms.translateX = 0;\n  transforms.translateY = 0;\n  transforms.scaleFactorX = 0;\n  transforms.scaleFactorY = 0;\n  transforms.rotateAngle = 0;\n  transforms.opacityFactor = 0;\n  transforms.anchorX = 0;\n  transforms.anchorY = 0;\n  transforms.paddingX = 0;\n  transforms.paddingY = 0;\n  transforms.paddingAnchorX = 0;\n  transforms.paddingAnchorY = 0;\n  transforms.isTranslate = false;\n\n  transforms.dataString = '';\n  transforms.isTween = false;\n  transforms.tweenShape = '';\n  transforms.refObj = '';\n  transforms.combined = '';\n\n  transforms.translate = '';\n  transforms.rotate = '';\n  transforms.scale = '';\n  transforms.opacity = 1;\n  transforms.hide = false;\n  transforms.show = false;\n  transforms.inPoint = -1;\n  transforms.outPoint = -1;\n  transforms.isLayer = true;\n  transforms.stageObj = '';\n  transforms.isSet = false;\n  return transforms;\n}\n\nfunction getEmptyStageTransform() {\n  var transforms = {};\n  transforms.stageObj = '';\n  transforms.refObj = '';\n  transforms.hide = false;\n  transforms.show = false;\n  return transforms;\n}\n\nfunction findExistingTransform(transforms, animationId, frame) {\n  if (animation[animationId]._scene[parseInt(frame)] === undefined) {\n    console.log(frame);\n    return transforms;\n  }\n  for (var i = 0; i < animation[animationId]._scene[parseInt(frame)]._transform.length; i++) {\n    if (animation[animationId]._scene[parseInt(frame)]._transform[i].refObj == transforms.refObj) {\n      transforms = animation[animationId]._scene[parseInt(frame)]._transform[i];\n      found = 1;\n      break;\n    }\n  }\n  return transforms;\n}\n\nfunction stageSequence(animationId, stageObj, inPoint, outPoint) {\n  if (outPoint > animation[animationId]._totalFrames) {\n    outPoint = animation[animationId]._totalFrames;\n  }\n  var transforms = getEmptyStageTransform();\n  var found = 0;\n  if (inPoint > -1) {\n    frame = inPoint;\n    for (var i = 0; i < animation[animationId]._scene[parseInt(frame)]._transform.length; i++) {\n      if (animation[animationId]._scene[parseInt(frame)]._transform[i].stageObj == stageObj) {\n        transforms = animation[animationId]._scene[parseInt(frame)]._transform[i];\n        found = 1;\n        break;\n      }\n    }\n    transforms.stageObj = stageObj;\n    transforms.show = true;\n    animation[animationId]._scene[parseInt(frame)]._transform.push(transforms);\n  }\n\n  transforms = getEmptyStageTransform();\n  found = 0;\n  if (outPoint > -1) {\n    frame = outPoint;\n    for (var i = 0; i < animation[animationId]._scene[parseInt(frame)]._transform.length; i++) {\n      if (animation[animationId]._scene[parseInt(frame)]._transform[i].stageObj == stageObj) {\n        transforms = animation[animationId]._scene[parseInt(frame)]._transform[i];\n        found = 1;\n        break;\n      }\n    }\n    transforms.stageObj = stageObj;\n    transforms.hide = true;\n    animation[animationId]._scene[parseInt(frame)]._transform.push(transforms);\n  } else {\n    frame = 0;\n  }\n\n  transforms = getEmptyStageTransform();\n  found = 0;\n  if (outPoint > -1 && inPoint > 0) {\n    frame = 0;\n    for (var i = 0; i < animation[animationId]._scene[parseInt(frame)]._transform.length; i++) {\n      if (animation[animationId]._scene[parseInt(frame)]._transform[i].stageObj == stageObj) {\n        transforms = animation[animationId]._scene[parseInt(frame)]._transform[i];\n        found = 1;\n        break;\n      }\n    }\n    transforms.stageObj = stageObj;\n    transforms.hide = true;\n    animation[animationId]._scene[parseInt(frame)]._transform.push(transforms);\n  }\n\n  var lastState = 0;\n  if (frame > 1) {\n    for (var j = 0; j <= animation[animationId]._totalFrames; j++) {\n      for (var i = 0; i < animation[animationId]._scene[j]._transform.length; i++) {\n        if (animation[animationId]._scene[j]._transform[i].stageObj == stageObj) {\n          if (animation[animationId]._scene[j]._transform[i].show) {\n            lastState = 1;\n          }\n          if (animation[animationId]._scene[j]._transform[i].hide) {\n            lastState = 0;\n          }\n          if (lastState == 1) {\n            animation[animationId]._scene[j]._transform[i].show = true;\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction addGroupPositionTransform(frame, position, isLayer, animationId, refKey, addTransformation, objectId, depth) {\n  if (frame < 0 || addTransformation < 1) {\n    return;\n  }\n  if (frame > animation[animationId]._totalFrames) {\n    return;\n  }\n  var transforms = getEmptyTransform();\n\n  var posX = 0;\n\n  if (isLayer) {\n    if (animation[animationId].hasOwnProperty('_currentLayerGroup')) {\n      if (animation[animationId]._currentLayerGroup._inPoint >= 0) {\n        console.log('inpoint');\n        transforms.inPoint = parseInt(animation[animationId]._currentLayerGroup._inPoint);\n      }\n      if (animation[animationId]._currentLayerGroup._outPoint > 0) {\n        transforms.outPoint = parseInt(animation[animationId]._currentLayerGroup._outPoint);\n      }\n    } else {\n      if (animation[animationId]._currentLayer._inPoint >= 0) {\n        console.log('inpoint');\n        transforms.inPoint = parseInt(animation[animationId]._currentLayer._inPoint);\n      }\n      if (animation[animationId]._currentLayer._outPoint > 0) {\n        transforms.outPoint = parseInt(animation[animationId]._currentLayer._outPoint);\n      }\n    }\n  } else {\n  }\n\n  if (transforms.inPoint < 0 && transforms.outPoint < 0) {\n    if (frame != transforms.inPoint && frame != transforms.outPoint) {\n      if (Array.isArray(position)) {\n        posX = position[0];\n        if (Number.isNaN(posX)) {\n          return;\n        }\n      } else {\n        posX = position;\n        if (Number.isNaN(posX)) {\n          return;\n        }\n      }\n    }\n  }\n\n  if (isLayer) {\n    transforms.isLayer = true;\n    if (objectId.td > 0) {\n      transforms.refObj = animationId + '_' + depth + '_layerGroup' + objectId._layer;\n    } else {\n      transforms.refObj = animationId + '_' + depth + '_layerTranslate' + objectId._layer;\n    }\n    transforms.refObjOther = animationId + '_' + depth + '_layerGroup' + objectId._layer;\n  } else {\n    transforms.isLayer = false;\n    transforms.refObj = animationId + '_group' + animation[animationId]._currentShapeGroup;\n    transforms.refObjOther = animationId + '_group' + animation[animationId]._currentShapeGroup;\n  }\n\n  transforms.anchorX = objectId._anchorX;\n  transforms.anchorY = objectId._anchorY;\n\n  transforms = findExistingTransform(transforms, animationId, frame);\n\n  if (animation[animationId]._instated.hasOwnProperty(transforms.refObj)) {\n  } else {\n    animation[animationId]._refObj.push(transforms.refObj);\n    animation[animationId]._objSize[transforms.refObj] = [];\n    animation[animationId]._objSize[transforms.refObj][0] = document\n      .getElementById(transforms.refObj)\n      .getBoundingClientRect().width;\n    animation[animationId]._objSize[transforms.refObj][1] = document\n      .getElementById(transforms.refObj)\n      .getBoundingClientRect().height;\n  }\n  if (objectId._layer == 3) {\n    console.log(\n      'ORIGINAL: ' +\n        animation[animationId]._objSize[transforms.refObj][0] +\n        ', ' +\n        animation[animationId]._objSize[transforms.refObj][1] +\n        ' // ' +\n        transforms.anchorX +\n        ', ' +\n        transforms.anchorY,\n    );\n  }\n\n  var posY = 0;\n\n  if (refKey == 'r') {\n    transforms.rotateAngle = transforms.rotateAngle + posX;\n    if (objectId.hasOwnProperty('_anchorX') && objectId.hasOwnProperty('_anchorY')) {\n      transforms.rotate = 'rotate(' + transforms.rotateAngle + ',' + objectId._anchorX + ',' + objectId._anchorY + ') ';\n    } else {\n      transforms.rotate =\n        'rotate(' +\n        transforms.rotateAngle +\n        ',' +\n        document.getElementById(transforms.refObj).getBoundingClientRect().width / 2 +\n        ',' +\n        document.getElementById(transforms.refObj).getBoundingClientRect().height / 2 +\n        ') ';\n    }\n  }\n  if (refKey == 's') {\n    transforms.scaleFactorX = transforms.scaleFactorX + posX;\n    tempBoundingW = animation[animationId]._objSize[transforms.refObj][0];\n    tempBoundingH = animation[animationId]._objSize[transforms.refObj][1];\n    var currentScaleX;\n    var currentScaleY;\n    if (position.length > 1) {\n      transforms.scaleFactorY = transforms.scaleFactorY + position[1];\n      currentScaleX = 1 - transforms.scaleFactorX / 100;\n      currentScaleY = 1 - transforms.scaleFactorY / 100;\n    } else {\n      currentScaleX = 1 - transforms.scaleFactorX / 100;\n      currentScaleY = 1 - transforms.scaleFactorX / 100;\n    }\n    transforms.scale = 'scale(' + transforms.scaleFactorX / 100 + ',' + transforms.scaleFactorY / 100 + ') ';\n    transforms.paddingX = (transforms.anchorX - tempBoundingW) * currentScaleX + tempBoundingW * currentScaleX;\n    transforms.paddingY = (transforms.anchorY - tempBoundingH) * currentScaleY + tempBoundingH * currentScaleY;\n    transforms.paddingAnchorX = transforms.anchorX * currentScaleX;\n    transforms.paddingAnchorY = transforms.anchorY * currentScaleY;\n  }\n  if (refKey == 'p') {\n    posY = position[1];\n    if (objectId.hasOwnProperty('_anchorX')) {\n      transforms.translateX = transforms.translateX + posX;\n    }\n    if (objectId.hasOwnProperty('_anchorY')) {\n      transforms.translateY = transforms.translateY + posY;\n    }\n    transforms.translate =\n      'translate(' +\n      (transforms.translateX - transforms.anchorX) +\n      ',' +\n      (transforms.translateY - transforms.anchorY) +\n      ') ';\n    transforms.isTranslate = true;\n  }\n\n  if (!transforms.isTranslate) {\n    transforms.translate = 'translate(' + transforms.paddingX + ',' + transforms.paddingY + ') ';\n  }\n\n  if (refKey == 'o') {\n    transforms.opacityFactor = transforms.opacityFactor + posX;\n    transforms.opacity = transforms.opacityFactor / 100;\n  }\n\n  transforms.combined = transforms.translate + transforms.scale + transforms.rotate;\n  transforms.isSet = true;\n  animation[animationId]._scene[parseInt(frame)]._transform.push(transforms);\n\n  lastRefObj = transforms.refObj;\n\n  if (animation[animationId]._instated.hasOwnProperty(transforms.refObj)) {\n  } else {\n    animation[animationId]._instated[transforms.refObj] = 1;\n    animation[animationId]._scene[0]._transform.push(transforms);\n  }\n}\n\n///////////// PREP JSON\n\nfunction extrapolateValueKeyframe(valueKeyframeObj) {\n  return valueKeyframeObj;\n}\n\nfunction extrapolateOffsetKeyframe(\n  offsetKeyframeObj,\n  refKey,\n  isLayer,\n  animationId,\n  addTransformation,\n  objectId,\n  depth,\n) {\n  var i = 0;\n  var objLength = offsetKeyframeObj[refKey].k.length;\n  var oldLength = objLength;\n  var emptyPos = { x: 0, y: 0 };\n  var p2;\n  var gotI;\n  var gotO;\n\n  while (i < objLength - 1) {\n    gotI = true;\n    gotO = true;\n\n    if (offsetKeyframeObj[refKey].k[i].hasOwnProperty('_comp')) {\n    } else {\n      if (addTransformation > -1) {\n        addGroupPositionTransform(\n          offsetKeyframeObj[refKey].k[i].t,\n          offsetKeyframeObj[refKey].k[i].s,\n          isLayer,\n          animationId,\n          refKey,\n          addTransformation,\n          objectId,\n          depth,\n        );\n      }\n      if (offsetKeyframeObj[refKey].k[i].hasOwnProperty('e')) {\n        p2 = offsetKeyframeObj[refKey].k[i].e;\n      } else {\n        if (offsetKeyframeObj[refKey].k[i + 1].hasOwnProperty('s')) {\n          p2 = offsetKeyframeObj[refKey].k[i + 1].s;\n        }\n      }\n\n      if (offsetKeyframeObj[refKey].k[i + 1].hasOwnProperty('i') && refKey != 'ks') {\n        if (offsetKeyframeObj[refKey].k[i + 1].i.x < 1) offsetKeyframeObj[refKey].k[i + 1].i.x = 0.0;\n        if (offsetKeyframeObj[refKey].k[i + 1].i.y < 1) offsetKeyframeObj[refKey].k[i + 1].i.y = 0.0;\n      }\n      if (offsetKeyframeObj[refKey].k[i].hasOwnProperty('o') && refKey != 'ks') {\n        if (offsetKeyframeObj[refKey].k[i].o.x < 1) offsetKeyframeObj[refKey].k[i].o.x = 0.0;\n        if (offsetKeyframeObj[refKey].k[i].o.y < 1) offsetKeyframeObj[refKey].k[i].o.y = 0.0;\n      }\n\n      var returnedKeyframeObj;\n      if (\n        offsetKeyframeObj[refKey].k[i + 1].hasOwnProperty('i') &&\n        offsetKeyframeObj[refKey].k[i].hasOwnProperty('o') &&\n        gotI\n      ) {\n        returnedKeyframeObj = bezierCurve(\n          offsetKeyframeObj[refKey].k[i].s,\n          offsetKeyframeObj[refKey].k[i].o,\n          offsetKeyframeObj[refKey].k[i + 1].i,\n          p2,\n          offsetKeyframeObj[refKey].k[i].t,\n          offsetKeyframeObj[refKey].k[i + 1].t,\n          isLayer,\n          animationId,\n          refKey,\n          addTransformation,\n          objectId,\n          depth,\n        );\n      } else {\n        if (offsetKeyframeObj[refKey].k[i].hasOwnProperty('o') && gotO) {\n          returnedKeyframeObj = bezierCurve(\n            offsetKeyframeObj[refKey].k[i].s,\n            offsetKeyframeObj[refKey].k[i].o,\n            emptyPos,\n            p2,\n            offsetKeyframeObj[refKey].k[i].t,\n            offsetKeyframeObj[refKey].k[i + 1].t,\n            isLayer,\n            animationId,\n            refKey,\n            addTransformation,\n            objectId,\n            depth,\n          );\n        } else {\n          returnedKeyframeObj = bezierCurve(\n            offsetKeyframeObj[refKey].k[i].s,\n            emptyPos,\n            emptyPos,\n            p2,\n            offsetKeyframeObj[refKey].k[i].t,\n            offsetKeyframeObj[refKey].k[i + 1].t,\n            isLayer,\n            animationId,\n            refKey,\n            addTransformation,\n            objectId,\n            depth,\n          );\n        }\n      }\n      for (var s = returnedKeyframeObj.length - 1; s >= 0; s--) {\n        offsetKeyframeObj[refKey].k.splice(i + 1, 0, returnedKeyframeObj[s]);\n      }\n\n      objLength = offsetKeyframeObj[refKey].k.length;\n      i = i + (objLength - oldLength);\n      oldLength = objLength;\n    }\n    i = i + 1;\n  }\n  return offsetKeyframeObj;\n}\n\nfunction extrapolatePathPosition(\n  currentObj,\n  parentObj,\n  refKey,\n  isLayer,\n  animationId,\n  addTransformation,\n  objectId,\n  depth,\n) {\n  currentObj[refKey].k = [];\n  if (currentObj[refKey].x.k.length > 1) {\n    currentObj[refKey] = extrapolateOffsetKeyframe(\n      currentObj[refKey],\n      'x',\n      isLayer,\n      animationId,\n      false,\n      objectId,\n      depth,\n    );\n  } else {\n  }\n  if (currentObj[refKey].y.k.length > 1) {\n    currentObj[refKey] = extrapolateOffsetKeyframe(\n      currentObj[refKey],\n      'y',\n      isLayer,\n      animationId,\n      false,\n      objectId,\n      depth,\n    );\n  } else {\n  }\n\n  if (!Array.isArray(currentObj[refKey].x.k)) {\n    for (var i = 0; i < currentObj[refKey].y.k.length; i++) {\n      if (currentObj[refKey].y.k[i].hasOwnProperty('s')) {\n        currentObj[refKey].k.push({\n          i: [0, 0, 0],\n          o: [0, 0, 0],\n          s: [currentObj[refKey].x.k, currentObj[refKey].y.k[i].s[0], 0],\n          t: currentObj[refKey].y.k[i].t,\n        });\n      }\n    }\n\n    for (var i = 0; i < currentObj[refKey].k.length; i++) {\n      addGroupPositionTransform(\n        currentObj[refKey].k[i].t,\n        currentObj[refKey].k[i].s,\n        isLayer,\n        animationId,\n        refKey,\n        addTransformation,\n        objectId,\n        depth,\n      );\n    }\n\n    return currentObj;\n  }\n\n  if (!currentObj[refKey].y.k.isArray) {\n    for (var i = 0; i < currentObj[refKey].x.k.length; i++) {\n      if (currentObj[refKey].x.k[i].hasOwnProperty('s')) {\n        currentObj[refKey].k.push({\n          i: [0, 0, 0],\n          o: [0, 0, 0],\n          s: [currentObj[refKey].x.k[i].s[0], currentObj[refKey].y.k, 0],\n          t: currentObj[refKey].x.k[i].t,\n        });\n      }\n    }\n\n    for (var i = 0; i < currentObj[refKey].k.length; i++) {\n      addGroupPositionTransform(\n        currentObj[refKey].k[i].t,\n        currentObj[refKey].k[i].s,\n        isLayer,\n        animationId,\n        refKey,\n        addTransformation,\n        objectId,\n        depth,\n      );\n    }\n\n    return currentObj;\n  }\n\n  if (currentObj[refKey].x.k.length > currentObj[refKey].y.k.length) {\n    for (var i = 0; i < currentObj[refKey].x.k.length; i++) {\n      currentObj[refKey].k.push({\n        i: [0, 0, 0],\n        o: [0, 0, 0],\n        s: [currentObj[refKey].x.k[i].s[0], 0, 0],\n        t: currentObj[refKey].x.k[i].t,\n      });\n    }\n    for (var i = 0; i < currentObj[refKey].y.k.length; i++) {\n      if (currentObj[refKey].k[0].t > currentObj[refKey].y.k[i].t) {\n        currentObj[refKey].k.splice(i, 0, {\n          i: [0, 0, 0],\n          o: [0, 0, 0],\n          s: [0, currentObj[refKey].y.k[i].s[0], 0],\n          t: currentObj[refKey].y.k[i].t,\n        });\n      } else if (currentObj[refKey].k[0].t < currentObj[refKey].y.k[i].t) {\n        currentObj[refKey].k.push({\n          i: [0, 0, 0],\n          o: [0, 0, 0],\n          s: [0, currentObj[refKey].y.k[i].s[0], 0],\n          t: currentObj[refKey].y.k[i].t,\n        });\n      } else if (currentObj[refKey].k[0].t == currentObj[refKey].y.k[i].t) {\n        currentObj[refKey].k.s[1] = currentObj[refKey].y.k[i].s[0];\n      }\n    }\n\n    for (var i = 0; i < currentObj[refKey].k.length; i++) {\n      addGroupPositionTransform(\n        currentObj[refKey].k[i].t,\n        currentObj[refKey].k[i].s,\n        isLayer,\n        animationId,\n        refKey,\n        addTransformation,\n        objectId,\n      );\n    }\n\n    return currentObj;\n  }\n\n  if (currentObj[refKey].x.k.length < currentObj[refKey].y.k.length) {\n    for (var i = 0; i < currentObj[refKey].y.k.length; i++) {\n      currentObj[refKey].k.push({\n        i: [0, 0, 0],\n        o: [0, 0, 0],\n        s: [0, currentObj[refKey].y.k[i].s[0], 0],\n        t: currentObj[refKey].y.k[i].t,\n      });\n    }\n    for (var i = 0; i < currentObj[refKey].x.k.length; i++) {\n      if (currentObj[refKey].k[0].t > currentObj[refKey].x.k[i].t) {\n        currentObj[refKey].k.splice(i, 0, {\n          i: [0, 0, 0],\n          o: [0, 0, 0],\n          s: [currentObj[refKey].x.k[i].s[0], 0, 0],\n          t: currentObj[refKey].x.k[i].t,\n        });\n      } else if (currentObj[refKey].k[0].t < currentObj[refKey].x.k[i].t) {\n        currentObj[refKey].k.push({\n          i: [0, 0, 0],\n          o: [0, 0, 0],\n          s: [currentObj[refKey].x.k[i].s[0], 0, 0],\n          t: currentObj[refKey].x.k[i].t,\n        });\n      } else if (currentObj[refKey].k[0].t == currentObj[refKey].x.k[i].t) {\n        currentObj[refKey].k.s[0] = currentObj[refKey].x.k[i].s[0];\n      }\n    }\n\n    for (var i = 0; i < currentObj[refKey].k.length; i++) {\n      addGroupPositionTransform(\n        currentObj[refKey].k[i].t,\n        currentObj[refKey].k[i].s,\n        isLayer,\n        animationId,\n        refKey,\n        addTransformation,\n        objectId,\n        depth,\n      );\n    }\n\n    return currentObj;\n  }\n\n  return currentObj;\n}\n\nfunction getPosition(currentObj, parentObj, refKey, isLayer, animationId, addTransformation, objectId, depth) {\n  if (currentObj.hasOwnProperty(refKey)) {\n    if (currentObj[refKey].hasOwnProperty('x') && currentObj[refKey].hasOwnProperty('y')) {\n      currentObj = extrapolatePathPosition(\n        currentObj,\n        parentObj,\n        refKey,\n        isLayer,\n        animationId,\n        addTransformation,\n        objectId,\n        depth,\n      );\n    }\n    if (currentObj[refKey].hasOwnProperty('k')) {\n      if (currentObj[refKey].k.length > 1) {\n        if (currentObj[refKey].k[0].hasOwnProperty('s')) {\n          currentObj = extrapolateOffsetKeyframe(\n            currentObj,\n            refKey,\n            isLayer,\n            animationId,\n            addTransformation,\n            objectId,\n            depth,\n          );\n        }\n      }\n    }\n  }\n  return currentObj;\n}\n\nfunction prepShapeEl(shapeObj, referrer, animationId, addTransformation, depth) {\n  var newShape = document.createElementNS(xmlns, 'ellipse');\n  newShape.setAttribute('d', dataString);\n  newShape.setAttribute('fill', 'transparent');\n  newShape.setAttribute('id', animationId + '_shape' + shapeObj._shape);\n  newShape.classList.add('ellipse');\n  referrer.prepend(newShape);\n  shapeObj._isShape = true;\n  return shapeObj;\n}\n\nfunction prepShapeElKeyframe(shapeObj, referrer, animationId, addTransformation, depth) {\n  return shapeObj;\n}\n\nfunction prepShapeSr(shapeObj, referrer, animationId, addTransformation, depth) {\n  var newShape = document.createElementNS(xmlns, 'path');\n  newShape.setAttribute('d', dataString);\n  newShape.setAttribute('fill', 'transparent');\n  newShape.setAttribute('id', animationId + '_shape' + shapeObj._shape);\n  newShape.classList.add('star');\n  referrer.prepend(newShape);\n  shapeObj._isShape = true;\n  return shapeObj;\n}\n\nfunction prepShapeSrKeyframe(shapeObj, referrer, animationId, addTransformation, depth) {\n  return shapeObj;\n}\n\nfunction prepShapeRc(shapeObj, referrer, animationId, addTransformation, depth) {\n  var newShape = document.createElementNS(xmlns, 'rect');\n  newShape.setAttribute('fill', 'transparent');\n\n  newShape.setAttribute('width', shapeObj.s.k[0]);\n  newShape.setAttribute('height', shapeObj.s.k[1]);\n  if (shapeObj.p.k.length > 0) {\n    newShape.setAttribute('x', shapeObj.p.k[0] + shapeObj.s.k[0] / 2);\n    newShape.setAttribute('y', shapeObj.p.k[1] + shapeObj.s.k[1] / 2);\n  }\n  newShape.setAttribute('id', animationId + '_shape' + shapeObj._shape);\n  newShape.classList.add('rectangle');\n  referrer.prepend(newShape);\n  shapeObj._isShape = true;\n  return shapeObj;\n}\n\nfunction prepShapeRcKeyframe(shapeObj, referrer, animationId, addTransformation, depth) {\n  return shapeObj;\n}\n\nfunction prepShapeSh(shapeObj, referrer, animationId, addTransformation, depth) {\n  if (shapeObj.ks.k.hasOwnProperty('v')) {\n  } else {\n    if (shapeObj.ks.k[0].hasOwnProperty('s')) {\n      shapeObj = extrapolateOffsetKeyframe(shapeObj, 'ks', false, animationId, -1, shapeObj, depth);\n      var dataString = '';\n      var totalK;\n      if (shapeObj.ks.k[shapeObj.ks.k.length - 1].hasOwnProperty('s')) {\n        totalK = shapeObj.ks.k.length;\n      } else {\n        totalK = shapeObj.ks.k.length - 1;\n      }\n      for (var kCount = 0; kCount < totalK; kCount++) {\n        var transforms = getEmptyTransform();\n        transforms.isLayer = false;\n        transforms.isTween = true;\n        transforms.refObj = animationId + '_shape' + shapeObj._shape;\n        transforms.refObjOther = animationId + '_shape' + shapeObj._shape;\n        transforms = findExistingTransform(transforms, animationId, shapeObj.ks.k[kCount].t);\n        var dataString = 'M' + shapeObj.ks.k[kCount].s[0].v[0][0] + ',' + shapeObj.ks.k[kCount].s[0].v[0][1];\n        for (var i = 1; i < shapeObj.ks.k[kCount].s[0].v.length; i++) {\n          dataString =\n            dataString +\n            ' C' +\n            (shapeObj.ks.k[kCount].s[0].v[i - 1][0] + shapeObj.ks.k[kCount].s[0].o[i - 1][0]) +\n            ',' +\n            (shapeObj.ks.k[kCount].s[0].v[i - 1][1] + shapeObj.ks.k[kCount].s[0].o[i - 1][1]) +\n            ' ' +\n            (shapeObj.ks.k[kCount].s[0].v[i][0] + shapeObj.ks.k[kCount].s[0].i[i][0]) +\n            ',' +\n            (shapeObj.ks.k[kCount].s[0].v[i][1] + shapeObj.ks.k[kCount].s[0].i[i][1]) +\n            ' ' +\n            shapeObj.ks.k[kCount].s[0].v[i][0] +\n            ',' +\n            shapeObj.ks.k[kCount].s[0].v[i][1];\n        }\n        if (shapeObj.ks.k[0].s[0].c) {\n          dataString =\n            dataString +\n            ' C' +\n            (shapeObj.ks.k[kCount].s[0].v[shapeObj.ks.k[kCount].s[0].v.length - 1][0] +\n              shapeObj.ks.k[kCount].s[0].o[shapeObj.ks.k[kCount].s[0].v.length - 1][0]) +\n            ',' +\n            (shapeObj.ks.k[kCount].s[0].v[shapeObj.ks.k[kCount].s[0].v.length - 1][1] +\n              shapeObj.ks.k[kCount].s[0].o[shapeObj.ks.k[kCount].s[0].v.length - 1][1]) +\n            ' ' +\n            (shapeObj.ks.k[kCount].s[0].v[0][0] + shapeObj.ks.k[kCount].s[0].i[0][0]) +\n            ',' +\n            (shapeObj.ks.k[kCount].s[0].v[0][1] + shapeObj.ks.k[kCount].s[0].i[0][1]) +\n            ' ' +\n            shapeObj.ks.k[kCount].s[0].v[0][0] +\n            ',' +\n            shapeObj.ks.k[kCount].s[0].v[0][1];\n          dataString = dataString + ' Z';\n        }\n\n        transforms.dataString = dataString;\n        if (kCount == 0) {\n          var newShape = document.createElementNS(xmlns, 'path');\n          newShape.setAttribute('fill', 'transparent');\n          newShape.setAttribute('id', animationId + '_shape' + shapeObj._shape);\n          newShape.setAttribute('d', dataString);\n          newShape.classList.add('shape');\n          referrer.prepend(newShape);\n          shapeObj._isShape = true;\n        }\n\n        if (shapeObj.ks.k[kCount].t > animation[animationId]._totalFrames) {\n          break;\n        }\n        animation[animationId]._scene[parseInt(shapeObj.ks.k[kCount].t)]._transform.push(transforms);\n      }\n    }\n    return shapeObj;\n  }\n  var dataString = 'M' + shapeObj.ks.k.v[0][0] + ',' + shapeObj.ks.k.v[0][1];\n  for (var i = 1; i < shapeObj.ks.k.v.length; i++) {\n    dataString =\n      dataString +\n      ' C' +\n      (shapeObj.ks.k.v[i - 1][0] + shapeObj.ks.k.o[i - 1][0]) +\n      ',' +\n      (shapeObj.ks.k.v[i - 1][1] + shapeObj.ks.k.o[i - 1][1]) +\n      ' ' +\n      (shapeObj.ks.k.v[i][0] + shapeObj.ks.k.i[i][0]) +\n      ',' +\n      (shapeObj.ks.k.v[i][1] + shapeObj.ks.k.i[i][1]) +\n      ' ' +\n      shapeObj.ks.k.v[i][0] +\n      ',' +\n      shapeObj.ks.k.v[i][1];\n  }\n  if (shapeObj.ks.k.c) {\n    dataString =\n      dataString +\n      ' C' +\n      (shapeObj.ks.k.v[shapeObj.ks.k.v.length - 1][0] + shapeObj.ks.k.o[shapeObj.ks.k.v.length - 1][0]) +\n      ',' +\n      (shapeObj.ks.k.v[shapeObj.ks.k.v.length - 1][1] + shapeObj.ks.k.o[shapeObj.ks.k.v.length - 1][1]) +\n      ' ' +\n      (shapeObj.ks.k.v[0][0] + shapeObj.ks.k.i[0][0]) +\n      ',' +\n      (shapeObj.ks.k.v[0][1] + shapeObj.ks.k.i[0][1]) +\n      ' ' +\n      shapeObj.ks.k.v[0][0] +\n      ',' +\n      shapeObj.ks.k.v[0][1];\n    dataString = dataString + ' Z';\n  }\n  shapeObj._data = dataString;\n  var newShape = document.createElementNS(xmlns, 'path');\n  newShape.setAttribute('fill', 'transparent');\n  newShape.setAttribute('id', animationId + '_shape' + shapeObj._shape);\n  newShape.setAttribute('d', dataString);\n  newShape.classList.add('shape');\n  referrer.prepend(newShape);\n  shapeObj._isShape = true;\n  return shapeObj;\n}\n\nfunction prepShapeShKeyframe(shapeObj, referrer, animationId, depth) {\n  return shapeObj;\n}\n\nfunction prepShape(shapeObj, referrer, animationId, isMasked, depth) {\n  if (shapeObj.ty == 'fl') {\n    if (shapeObj.c.k.hasOwnProperty('s')) {\n      shapeObj = getPosition(shapeObj, null, 'c', false, animationId, 3, shapeObj, depth);\n    }\n  }\n  if (shapeObj.ty == 'tr') {\n    if (shapeObj.hasOwnProperty('a')) {\n      if (shapeObj.a.k.hasOwnProperty('s')) {\n        shapeObj = getPosition(shapeObj, null, 'a', false, animationId, 2, shapeObj, depth);\n        if (shapeObj.a.k[0].t > 0) {\n          shapeObj._startI = true;\n        }\n      }\n      if (shapeObj.a.k.length > 1) {\n        shapeObj._anchorX = shapeObj.a.k[0];\n        shapeObj._anchorY = shapeObj.a.k[1];\n      }\n    }\n    if (shapeObj.hasOwnProperty('p')) {\n      if (shapeObj.p.k.hasOwnProperty('s')) {\n        shapeObj = getPosition(shapeObj, null, 'p', false, animationId, 2, shapeObj, depth);\n        if (shapeObj.p.k[0].t > 0) {\n          shapeObj._startI = true;\n        }\n      }\n    }\n  }\n\n  if (shapeObj.ty == 'sh') {\n    if (shapeObj.hasOwnProperty('ks') && shapeObj.ks.k.length > 1) {\n      shapeObj = prepShapeShKeyframe(shapeObj, referrer, animationId, depth);\n    }\n    shapeObj = prepShapeSh(shapeObj, referrer, animationId, depth);\n  }\n\n  if (shapeObj.ty == 'rc') {\n    if (shapeObj.hasOwnProperty('ks') && shapeObj.ks.k.length > 1) {\n      shapeObj = prepShapeRcKeyframe(shapeObj, referrer, animationId, depth);\n    }\n    shapeObj = prepShapeRc(shapeObj, referrer, animationId, depth);\n  }\n\n  return shapeObj;\n}\n\nfunction createGradientDef(start, end, opacity, gradient, animationId) {\n  animation[animationId].gradientCount++;\n  var newDefId = animationId + '_gradient' + animation[animationId].gradientCount;\n  var newDef = document.createElementNS(xmlns, 'linearGradient');\n  newDef.setAttribute('id', newDefId);\n  newDef.setAttribute('spreadMethod', 'pad');\n  newDef.setAttribute('gradientUnits', 'userSpaceOnUse');\n  newDef.setAttribute('x1', start.k[0]);\n  newDef.setAttribute('x2', end.k[0]);\n  newDef.setAttribute('y1', start.k[1]);\n  newDef.setAttribute('y2', end.k[1]);\n  animation[animationId].defs.prepend(newDef);\n\n  var offsets = [];\n  var styles = [];\n  var opacities = [];\n  for (var i = 0; i < gradient.p; i++) {\n    offsets.push(gradient.k.k[i * 4 + 0] * 100 + '%');\n    styles.push(\n      'stop-color:rgb(' +\n        parseInt(gradient.k.k[i * 4 + 1] * 255) +\n        ',' +\n        parseInt(gradient.k.k[i * 4 + 2] * 255) +\n        ',' +\n        parseInt(gradient.k.k[i * 4 + 3] * 255) +\n        ');',\n    );\n    opacities.push('stop-opacity:1;');\n  }\n  if (gradient.k.k.length > gradient.p * 4) {\n    for (var i = 0; i < gradient.p; i++) {\n      opacities[i] = 'stop-opacity:' + gradient.k.k[i * 2 + gradient.p * 4 + 1] + ';';\n    }\n  }\n  for (var i = 0; i < gradient.p; i++) {\n    var newStop = document.createElementNS(xmlns, 'stop');\n    newStop.setAttribute('offset', offsets[i]);\n    newStop.setAttribute('style', styles[i] + opacities[i]);\n    newDef.append(newStop);\n  }\n\n  return 'url(#' + newDefId + ')';\n}\n\nvar lcEnum = {\n  1: 'butt',\n  2: 'round',\n  3: 'square',\n};\n\nvar ljEnum = {\n  1: 'miter',\n  2: 'round',\n  3: 'bevel',\n};\n\nfunction getStrokeString(color, opacity, width, lineCap, lineJoin, miterLimit) {\n  var strokeString = { color: '', opacity: 1, width: 1, lineCap: 'round', lineJoin: 'round', miterLimit: 0 };\n  strokeString.color = 'rgb(' + color.k[0] * 255 + ',' + color.k[1] * 255 + ',' + color.k[2] * 255 + ')';\n  strokeString.opacity = opacity.k / 100;\n  strokeString.width = width.k;\n  strokeString.lineCap = lcEnum[lineCap];\n  strokeString.lineJoin = lcEnum[lineJoin];\n  if (lineJoin == 1) {\n    strokeString.miterLimit = lineJoin;\n  }\n  return strokeString;\n}\n\nfunction getColorString(redVal, greenVal, blueVal) {\n  var color = 'rgb(' + redVal * 255 + ',' + greenVal * 255 + ',' + blueVal * 255 + ')';\n  return color;\n}\n\nfunction setShapeStrokes(shapesGroup, strokeToSet, animationId, isGradient) {\n  for (var i = 0; i < shapesGroup.length; i++) {\n    if (shapesGroup[i]._isShape) {\n      document.getElementById(animationId + '_shape' + shapesGroup[i]._shape).setAttribute('stroke', strokeToSet.color);\n      document\n        .getElementById(animationId + '_shape' + shapesGroup[i]._shape)\n        .setAttribute('stroke-width', strokeToSet.width);\n      document\n        .getElementById(animationId + '_shape' + shapesGroup[i]._shape)\n        .setAttribute('stroke-linecap', strokeToSet.lineCap);\n      document\n        .getElementById(animationId + '_shape' + shapesGroup[i]._shape)\n        .setAttribute('stroke-linejoin', strokeToSet.lineJoin);\n      if (strokeToSet.lineJoin == 1) {\n        document\n          .getElementById(animationId + '_shape' + shapesGroup[i]._shape)\n          .setAttribute('stroke-miterlimit', strokeToSet.miterLimit);\n      }\n    }\n  }\n}\n\nfunction setShapeColors(shapesGroup, colorToSet, animationId, isGradient, isMasked) {\n  for (var i = 0; i < shapesGroup.length; i++) {\n    if (shapesGroup[i]._isShape && typeof colorToSet !== 'undefined') {\n      document.getElementById(animationId + '_shape' + shapesGroup[i]._shape).setAttribute('fill', colorToSet);\n      document.getElementById(animationId + '_shape' + shapesGroup[i]._shape).setAttribute('fill-opacity', 1);\n    }\n  }\n}\n\nfunction getShapesGr(elementId, animationId, layerObj, referrer, refGroup, isMasked, depth) {\n  var currentColor;\n  var currentStroke;\n  var stroked = false;\n  for (var i = 0; i < layerObj.it.length; i++) {\n    layerObj._isGradient = false;\n    animation[animationId].shapeCount++;\n    if (layerObj.tt > 0) {\n      isMasked = layerObj.td;\n    }\n    if (layerObj.it[i].ty == 'gr') {\n      layerObj.it[i]._group = animation[animationId].shapeCount;\n      var newGroup = document.createElementNS(xmlns, 'g');\n      newGroup.setAttribute('id', animationId + '_group' + animation[animationId].shapeCount);\n      animation[animationId]._currentShapeGroup = animation[animationId].shapeCount;\n      referrer.prepend(newGroup);\n      layerObj.it[i] = getShapesGr(\n        elementId,\n        animationId,\n        layerObj.it[i],\n        newGroup,\n        animationId + '_group' + animation[animationId].shapeCount,\n        isMasked,\n        depth,\n      );\n    } else {\n      layerObj.it[i]._shape = animation[animationId].shapeCount;\n      layerObj.it[i] = prepShape(layerObj.it[i], referrer, animationId, isMasked);\n      if (layerObj.it[i].ty == 'tr') {\n        layerObj.it[i]._trIndex = i;\n        if (layerObj.it[i].p.hasOwnProperty('k')) {\n          if (layerObj.it[i].p.k.length > 1) {\n            if (layerObj.it[i].hasOwnProperty('a')) {\n              document\n                .getElementById(refGroup)\n                .setAttribute(\n                  'transform',\n                  'matrix(1,0,0,1,' +\n                    (layerObj.it[i].p.k[0] - layerObj.it[i].a.k[0]) +\n                    ',' +\n                    (layerObj.it[i].p.k[1] - layerObj.it[i].a.k[1]) +\n                    ')',\n                );\n            } else {\n              document\n                .getElementById(refGroup)\n                .setAttribute(\n                  'transform',\n                  'matrix(1,0,0,1,' + layerObj.it[i].p.k[0] + ',' + layerObj.it[i].p.k[1] + ')',\n                );\n            }\n          }\n        }\n      }\n      if (layerObj.it[i].ty == 'fl') {\n        if (layerObj.it[i].c.k.length > 1) {\n          currentColor = getColorString(layerObj.it[i].c.k[0], layerObj.it[i].c.k[1], layerObj.it[i].c.k[2]);\n        }\n      }\n      if (layerObj.it[i].ty == 'st') {\n        if (layerObj.it[i].c.k.length > 1) {\n          currentStroke = getStrokeString(\n            layerObj.it[i].c,\n            layerObj.it[i].o,\n            layerObj.it[i].w,\n            layerObj.it[i].lc,\n            layerObj.it[i].lj,\n            layerObj.it[i].ml,\n          );\n          stroked = true;\n        }\n      }\n      if (layerObj.it[i].ty == 'gf') {\n        layerObj._isGradient = true;\n        currentColor = createGradientDef(\n          layerObj.it[i].s,\n          layerObj.it[i].e,\n          layerObj.it[i].o,\n          layerObj.it[i].g,\n          animationId,\n        );\n      }\n    }\n  }\n  setShapeColors(layerObj.it, currentColor, animationId, layerObj._isGradient, isMasked);\n  if (stroked) {\n    setShapeStrokes(layerObj.it, currentStroke, animationId);\n  }\n  return layerObj;\n}\n\nfunction getShapes(elementId, animationId, layerObj, referrer, refGroup, isMasked, depth) {\n  var currentColor;\n  var currentStroke;\n  var stroked = false;\n  for (var i = 0; i < layerObj.shapes.length; i++) {\n    layerObj._isGradient = false;\n    animation[animationId].shapeCount++;\n    if (layerObj.tt > 0) {\n      isMasked = layerObj.td;\n    }\n    if (layerObj.shapes[i].ty == 'gr') {\n      layerObj.shapes[i]._group = animation[animationId].shapeCount;\n      var newGroup = document.createElementNS(xmlns, 'g');\n      newGroup.setAttribute('id', animationId + '_group' + animation[animationId].shapeCount);\n      newGroup.setAttribute('opacity', 1);\n      animation[animationId]._currentShapeGroup = animation[animationId].shapeCount;\n      referrer.prepend(newGroup);\n      layerObj.shapes[i] = getShapesGr(\n        elementId,\n        animationId,\n        layerObj.shapes[i],\n        newGroup,\n        animationId + '_group' + animation[animationId].shapeCount,\n        isMasked,\n        depth,\n      );\n    } else {\n      layerObj.shapes[i]._shape = animation[animationId].shapeCount;\n      layerObj.shapes[i] = prepShape(layerObj.shapes[i], referrer, animationId, isMasked);\n      if (layerObj.shapes[i].ty == 'tr') {\n        layerObj.shapes[i]._trIndex = i;\n        if (layerObj.shapes[i].p.hasOwnProperty('k')) {\n          if (layerObj.shapes[i].p.k > 1) {\n            document\n              .getElementById(animationId + '_' + depth + '_layerGroup' + layerObj._layer)\n              .setAttribute(\n                'transform',\n                'matrix(1,0,0,1,' + layerObj.shapes[i].p.k[0] + ',' + layerObj.shapes[i].p.k[1] + ')',\n              );\n          }\n        }\n      }\n      if (layerObj.shapes[i].ty == 'fl') {\n        if (layerObj.shapes[i].c.k.length > 1) {\n          currentColor = getColorString(\n            layerObj.shapes[i].c.k[0],\n            layerObj.shapes[i].c.k[1],\n            layerObj.shapes[i].c.k[2],\n          );\n        }\n      }\n      if (layerObj.shapes[i].ty == 'st') {\n        if (layerObj.shapes[i].c.k.length > 1) {\n          currentStroke = getStrokeString(\n            layerObj.shapes[i].c,\n            layerObj.shapes[i].o,\n            layerObj.shapes[i].w,\n            layerObj.shapes[i].lc,\n            layerObj.shapes[i].lj,\n            layerObj.shapes[i].ml,\n          );\n          stroked = true;\n        }\n      }\n      if (layerObj.shapes[i].ty == 'gf') {\n        layerObj._isGradient = true;\n        currentColor = createGradientDef(\n          layerObj.shapes[i].s,\n          layerObj.shapes[i].e,\n          layerObj.shapes[i].o,\n          layerObj.shapes[i].g,\n          animationId,\n        );\n      }\n    }\n    //console.log(\"leastY \" + layerObj._leastY);\n  }\n  setShapeColors(layerObj.shapes, currentColor, animationId, layerObj._isGradient, isMasked);\n  if (stroked) {\n    setShapeStrokes(layerObj.shapes, currentStroke, animationId);\n  }\n  return layerObj;\n}\n\nfunction resolveParents(animationId, layerId, lastMaskId, passedObj, passedKey, depth) {\n  var newGroup;\n  var newTranslateGroup;\n\n  for (var j = 0; j < passedObj[passedKey].length; j++) {\n    if (passedObj[passedKey][j].ind == passedObj[passedKey][layerId].parent) {\n      if (passedObj[passedKey][j].tt > 0) {\n        for (var k = j - 1; k >= 0; k--) {\n          if (passedObj[passedKey][k].td > 0) {\n            passedObj[passedKey][j]._mask =\n              '_' + animationId + '_' + depth + '_layerMask' + passedObj[passedKey][k].ind;\n            passedObj[passedKey][j]._isMasked = true;\n            break;\n          }\n        }\n      }\n      if (!passedObj[passedKey][j]._addedToDom) {\n        resolveParents(animationId, j, lastMaskId, passedObj, passedKey, depth);\n      }\n      animation[animationId].layerCount++;\n      passedObj[passedKey][layerId]._parent = passedObj[passedKey][j]._layer;\n      newLayer = document.createElementNS(xmlns, 'g');\n      newLayer.setAttribute('id', animationId + '_' + depth + '_layer' + passedObj[passedKey][layerId]._layer);\n      newLayer.setAttribute('mask', lastMaskId);\n      newLayer.setAttribute('opacity', 1);\n\n      document\n        .getElementById(animationId + '_' + depth + '_layerTranslate' + passedObj[passedKey][layerId]._parent)\n        .prepend(newLayer);\n      newTranslateGroup = document.createElementNS(xmlns, 'g');\n      newTranslateGroup.setAttribute(\n        'id',\n        animationId + '_' + depth + '_layerTranslate' + passedObj[passedKey][layerId]._layer,\n      );\n      newTranslateGroup.setAttribute('opacity', 1);\n      newLayer.prepend(newTranslateGroup);\n      if (passedObj[passedKey][layerId].w > 0) {\n        newLayer.style.width = passedObj[passedKey][layerId].w;\n      }\n      if (passedObj[passedKey][layerId].h > 0) {\n        newLayer.style.height = passedObj[passedKey][layerId].h;\n      }\n      newGroup = document.createElementNS(xmlns, 'g');\n      newGroup.setAttribute('id', animationId + '_' + depth + '_layerGroup' + passedObj[passedKey][layerId]._layer);\n      newGroup.setAttribute('opacity', 1);\n      newTranslateGroup.prepend(newGroup);\n\n      passedObj[passedKey][j]._child.push('_layerGroup' + passedObj[passedKey][layerId].parent);\n      passedObj[passedKey][j]._childId.push(layerId);\n      passedObj[passedKey][j]._addedToDom = true;\n      return;\n    }\n  }\n}\n\nfunction getLayers(elementId, animationId, elementObj, passedObj, passedKey, depth) {\n  animation[animationId].depth++;\n  depth = animation[animationId].depth;\n  var newLayer;\n  var newGroup;\n  var newMask;\n  var newTranslateGroup;\n  var posX;\n  var posY;\n  var lastMaskId = '';\n  for (var i = 0; i < passedObj[passedKey].length; i++) {\n    passedObj.layerCount++;\n    passedObj[passedKey][i]._layer = passedObj[passedKey][i].ind;\n    passedObj[passedKey][i]._child = [];\n    passedObj[passedKey][i]._childId = [];\n    if (passedObj[passedKey][i].parent > 0) {\n    } else {\n      if (passedObj[passedKey][i].td > 0) {\n        passedObj[passedKey][i]._isMask = true;\n        newMask = document.createElementNS(xmlns, 'mask');\n        lastMaskId = '_' + animationId + '_' + depth + '_layerMask' + passedObj[passedKey][i].ind;\n        newMask.setAttribute('id', lastMaskId);\n        newMask.setAttribute('mask-type', 'alpha');\n        newMask.setAttribute('opacity', 1);\n        animation[animationId].defs.prepend(newMask);\n\n        newLayer = document.createElementNS(xmlns, 'g');\n        newLayer.setAttribute('id', animationId + '_' + depth + '_layer' + passedObj[passedKey][i].ind);\n        newLayer.setAttribute('style', 'display: block;');\n        newLayer.setAttribute('opacity', 1);\n        newMask.prepend(newLayer);\n      } else {\n        newLayer = document.createElementNS(xmlns, 'g');\n        newLayer.setAttribute('id', animationId + '_' + depth + '_layer' + passedObj[passedKey][i].ind);\n        newLayer.setAttribute('opacity', 1);\n        elementObj.prepend(newLayer);\n        if (passedObj[passedKey][i].tt > 0) {\n          passedObj[passedKey][i]._mask = lastMaskId;\n          passedObj[passedKey][i]._isMasked = true;\n        }\n      }\n      passedObj[passedKey][i]._addedToDom = true;\n\n      newTranslateGroup = document.createElementNS(xmlns, 'g');\n      newTranslateGroup.setAttribute(\n        'id',\n        animationId + '_' + depth + '_layerTranslate' + passedObj[passedKey][i]._layer,\n      );\n      newTranslateGroup.setAttribute('opacity', 1);\n      newLayer.prepend(newTranslateGroup);\n      if (passedObj[passedKey][i].w > 0) {\n        newLayer.style.width = passedObj[passedKey][i].w;\n      }\n      if (passedObj[passedKey][i].h > 0) {\n        newLayer.style.height = passedObj[passedKey][i].h;\n      }\n      newGroup = document.createElementNS(xmlns, 'g');\n      newGroup.setAttribute('id', animationId + '_' + depth + '_layerGroup' + passedObj[passedKey][i]._layer);\n      newGroup.setAttribute('opacity', 1);\n      newTranslateGroup.prepend(newGroup);\n    }\n  }\n\n  for (var i = 0; i < passedObj.layers.length; i++) {\n    passedObj.layerCount = passedObj[passedKey][i]._layer;\n    if (passedObj[passedKey][i].parent > 0) {\n      for (var j = 0; j < passedObj.layers.length; j++) {\n        if (passedObj[passedKey][j].ind == passedObj[passedKey][i].parent) {\n          if (passedObj[passedKey][i].tt > 0) {\n            for (var k = i - 1; k >= 0; k--) {\n              if (passedObj[passedKey][k].td > 0) {\n                passedObj[passedKey][i]._mask =\n                  '_' + animationId + '_' + depth + '_layerMask' + passedObj[passedKey][k].ind;\n                break;\n              }\n            }\n          }\n          passedObj.layerCount++;\n          if (!passedObj[passedKey][j]._addedToDom) {\n            resolveParents(animationId, j, lastMaskId, passedObj, passedKey, depth);\n          }\n          passedObj[passedKey][i]._parent = passedObj[passedKey][j]._layer;\n          newLayer = document.createElementNS(xmlns, 'g');\n          newLayer.setAttribute('id', animationId + '_' + depth + '_layer' + passedObj[passedKey][i]._layer);\n          newLayer.setAttribute('opacity', 1);\n\n          document\n            .getElementById(animationId + '_' + depth + '_layerTranslate' + passedObj[passedKey][i]._parent)\n            .prepend(newLayer);\n          newTranslateGroup = document.createElementNS(xmlns, 'g');\n          newTranslateGroup.setAttribute(\n            'id',\n            animationId + '_' + depth + '_layerTranslate' + passedObj[passedKey][i]._layer,\n          );\n          newTranslateGroup.setAttribute('opacity', 1);\n          newLayer.prepend(newTranslateGroup);\n          if (passedObj[passedKey][i].w > 0) {\n            newLayer.style.width = passedObj[passedKey][i].w;\n          }\n          if (passedObj[passedKey][i].h > 0) {\n            newLayer.style.height = passedObj[passedKey][i].h;\n          }\n          newGroup = document.createElementNS(xmlns, 'g');\n          newGroup.setAttribute('id', animationId + '_' + depth + '_layerGroup' + passedObj[passedKey][i]._layer);\n          newGroup.setAttribute('opacity', 1);\n          newTranslateGroup.prepend(newGroup);\n\n          passedObj[passedKey][j]._child.push(\n            animationId + '_' + depth + '_layerGroup' + passedObj[passedKey][i].parent,\n          );\n          passedObj[passedKey][j]._childId.push(i);\n          passedObj[passedKey][j]._addedToDom = true;\n        }\n      }\n    }\n  }\n  for (var i = 0; i < passedObj.layers.length; i++) {\n    passedObj[passedKey][i]._inPoint = -1;\n    passedObj[passedKey][i]._outPoint = -1;\n    if (passedObj[passedKey][i].hasOwnProperty('ip') && passedObj[passedKey][i].ip >= 0) {\n      passedObj[passedKey][i]._inPoint = passedObj[passedKey][i].ip;\n    }\n    if (passedObj[passedKey][i].hasOwnProperty('op') && passedObj[passedKey][i].op > 0) {\n      passedObj[passedKey][i]._outPoint = passedObj[passedKey][i].op;\n      if (passedObj[passedKey][i]._outPoint > passedObj._totalFrames) {\n        passedObj[passedKey][i]._outPoint = passedObj._totalFrames;\n      }\n    } else {\n      passedObj[passedKey][i]._outPoint = passedObj._totalFrames;\n    }\n    stageSequence(\n      animationId,\n      animationId + '_' + depth + '_layerGroup' + passedObj[passedKey][i]._layer,\n      passedObj[passedKey][i]._inPoint,\n      passedObj[passedKey][i]._outPoint,\n    );\n\n    passedObj.layerCount = passedObj[passedKey][i]._layer;\n    newLayer = document.getElementById(animationId + '_' + depth + '_layer' + passedObj[passedKey][i]._layer);\n    newGroup = document.getElementById(animationId + '_' + depth + '_layerGroup' + passedObj[passedKey][i]._layer);\n    if (passedObj[passedKey][i].tt > 0) {\n      document\n        .getElementById(animationId + '_' + depth + '_layer' + passedObj[passedKey][i]._layer)\n        .setAttribute('mask', 'url(#' + passedObj[passedKey][i]._mask + ')');\n      document\n        .getElementById(animationId + '_' + depth + '_layer' + passedObj[passedKey][i]._layer)\n        .setAttribute('style', 'display: block;');\n    }\n    passedObj._currentLayer = passedObj[passedKey][i]._layer;\n    passedObj._currentLayer._inPoint = passedObj[passedKey][i]._inPoint;\n    passedObj._currentLayer._outPoint = passedObj[passedKey][i]._outPoint;\n    if (passedObj[passedKey][i].hasOwnProperty('refId') && passedObj.hasOwnProperty('assets')) {\n      var tempRef = -1;\n      for (var m = 0; m < passedObj.assets.length; m++) {\n        if (passedObj.assets[m].id == passedObj[passedKey][i].refId) {\n          tempRef = m;\n          break;\n        }\n      }\n      if (tempRef >= 0) {\n        passedObj.assets[tempRef] = getLayers(\n          elementId,\n          animationId,\n          newGroup,\n          passedObj.assets[tempRef],\n          'layers',\n          depth,\n        );\n      }\n    }\n    if (passedObj[passedKey][i].hasOwnProperty('shapes')) {\n      passedObj._currentLayerGroup = passedObj[passedKey][i]._layer;\n      passedObj._currentLayerGroup._inPoint = passedObj[passedKey][i]._inPoint;\n      passedObj._currentLayerGroup._outPoint = passedObj[passedKey][i]._outPoint;\n      passedObj[passedKey][i] = getShapes(\n        elementId,\n        animationId,\n        passedObj[passedKey][i],\n        newGroup,\n        animationId + '_' + depth + '_layerGroup' + passedObj[passedKey][i]._layer,\n        false,\n        passedObj[passedKey][i].td,\n        depth,\n      );\n      if (passedObj[passedKey][i].hasOwnProperty('shapes')) {\n        passedObj._boundingX = newGroup.getBoundingClientRect().width / 2;\n        passedObj._boundingY = newGroup.getBoundingClientRect().height / 2;\n      }\n    } else {\n      if (passedObj[passedKey][i]._inPoint > 0) {\n        //console.log(\"layer: \" + i);\n        //newLayer.style.display = 'none';\n      }\n    }\n    if (passedObj[passedKey][i].hasOwnProperty('ks')) {\n      if (passedObj[passedKey][i].ks.hasOwnProperty('a')) {\n        if (passedObj[passedKey][i].ks.a.hasOwnProperty('k')) {\n          if (passedObj[passedKey][i].ks.a.k.length > 1) {\n            passedObj[passedKey][i]._anchorX = passedObj[passedKey][i].ks.a.k[0];\n            passedObj[passedKey][i]._anchorY = passedObj[passedKey][i].ks.a.k[1];\n          }\n        }\n      }\n\n      if (passedObj[passedKey][i].ks.hasOwnProperty('p')) {\n        passedObj[passedKey][i].ks = getPosition(\n          passedObj[passedKey][i].ks,\n          null,\n          'p',\n          true,\n          animationId,\n          1,\n          passedObj[passedKey][i],\n          depth,\n        );\n        if (passedObj[passedKey][i].ks.p.hasOwnProperty('k')) {\n          if (passedObj[passedKey][i].ks.p.k.length > 1) {\n            if (passedObj[passedKey][i].ks.p.k[0].hasOwnProperty('s')) {\n            } else {\n              if (passedObj[passedKey][i]._anchorX != 0) {\n                posX = passedObj[passedKey][i].ks.p.k[0] - passedObj[passedKey][i]._anchorX;\n              } else {\n                posX = passedObj[passedKey][i].ks.p.k[0]; //passedObj._boundingX;\n              }\n              if (passedObj[passedKey][i]._anchorY != 0) {\n                posY = passedObj[passedKey][i].ks.p.k[1] - passedObj[passedKey][i]._anchorY;\n              } else {\n                posY = passedObj[passedKey][i].ks.p.k[1]; //passedObj._boundingY;\n              }\n              if (passedObj[passedKey][i].td > 0) {\n                document\n                  .getElementById(animationId + '_' + depth + '_layerGroup' + passedObj[passedKey][i]._layer)\n                  .setAttribute('transform', 'matrix(1,0,0,1,' + posX + ',' + posY + ')');\n              } else {\n                document\n                  .getElementById(animationId + '_' + depth + '_layer' + passedObj[passedKey][i]._layer)\n                  .setAttribute('transform', 'matrix(1,0,0,1,' + posX + ',' + posY + ')');\n              }\n              passedObj[passedKey][i]._posX = posX;\n              passedObj[passedKey][i]._posY = posY;\n            }\n          }\n        }\n      }\n\n      if (passedObj[passedKey][i].ks.hasOwnProperty('r')) {\n        if (passedObj[passedKey][i].ks.r.k.length > 1) {\n          if (passedObj[passedKey][i].ks.r.k[0].hasOwnProperty('s')) {\n            passedObj[passedKey][i].ks = getPosition(\n              passedObj[passedKey][i].ks,\n              null,\n              'r',\n              true,\n              animationId,\n              1,\n              passedObj[passedKey][i],\n              depth,\n            );\n          }\n        }\n      }\n      if (passedObj[passedKey][i].ks.hasOwnProperty('s')) {\n        if (passedObj[passedKey][i].ks.s.k.length > 1) {\n          if (passedObj[passedKey][i].ks.s.k[0].hasOwnProperty('s')) {\n            passedObj[passedKey][i].ks = getPosition(\n              passedObj[passedKey][i].ks,\n              null,\n              's',\n              true,\n              animationId,\n              1,\n              passedObj[passedKey][i],\n              depth,\n            );\n          }\n        }\n      }\n      if (passedObj[passedKey][i].ks.hasOwnProperty('o')) {\n        if (passedObj[passedKey][i].ks.o.k.length > 1) {\n          if (passedObj[passedKey][i].ks.o.k[0].hasOwnProperty('s')) {\n            passedObj[passedKey][i].ks = getPosition(\n              passedObj[passedKey][i].ks,\n              null,\n              'o',\n              true,\n              animationId,\n              1,\n              passedObj[passedKey][i],\n              depth,\n            );\n          }\n        }\n      }\n    }\n  }\n  return passedObj;\n}\n\nfunction buildGraph(elementId, animationId, elementObj, autoplay, loop, customName) {\n  animation[animationId]._loaded = false;\n  //try {\n  animation[animationId].depth = 0;\n  animation[animationId].shapeCount = 0;\n  animation[animationId].layerCount = 0;\n  animation[animationId]._removed = false;\n  animation[animationId]._totalFrames = parseInt(animation[animationId].op - animation[animationId].ip);\n  animation[animationId]._frameTime = (1 / animation[animationId].fr) * 1000;\n  animation[animationId]._currentFrame = -1;\n  animation[animationId]._lastTime = Date.now();\n  animation[animationId]._autoplay = autoplay;\n  animation[animationId]._loop = loop;\n  animation[animationId]._customName = customName;\n  animation[animationId]._paused = false;\n\n  elementObj.style.width = animation[animationId].w;\n  elementObj.style.height = animation[animationId].h;\n  elementObj.setAttribute('width', animation[animationId].w);\n  elementObj.setAttribute('height', animation[animationId].h);\n\n  var newSVG = document.createElementNS(xmlns, 'svg');\n  newSVG.setAttribute('xmlns', xmlns);\n  newSVG.setAttributeNS(null, 'width', animation[animationId].w);\n  newSVG.setAttributeNS(null, 'height', animation[animationId].h);\n  newSVG.setAttributeNS(null, 'viewBox', '0 0 ' + animation[animationId].w + ' ' + animation[animationId].h);\n  newSVG.setAttributeNS(null, 'preserveAspectRatio', 'xMidYMid meet');\n  newSVG.style.width = '100%';\n  newSVG.style.height = '100%';\n  newSVG.setAttributeNS(null, 'id', '_svg' + animationId);\n  elementObj.prepend(newSVG);\n\n  animation[animationId].defs = document.createElementNS(xmlns, 'defs');\n  animation[animationId].defs.setAttributeNS(null, 'id', '_defs' + animationId);\n  animation[animationId].gradientCount = 0;\n  animation[animationId].maskCount = 0;\n  newSVG.prepend(animation[animationId].defs);\n\n  var newLayer = document.createElementNS(xmlns, 'g');\n  newLayer.setAttributeNS(null, 'id', '_lanim' + animationId);\n  newSVG.append(newLayer);\n\n  var newCompute = document.createElementNS(xmlns, 'g');\n  newCompute.setAttributeNS(null, 'id', '_compute' + animationId);\n  newCompute.style.display = 'none';\n  newLayer.prepend(newCompute);\n\n  animation[animationId]._scene = new Array(animation[animationId]._totalFrames + 1)\n    .fill(null)\n    .map(() => ({ _transform: [] }));\n  animation[animationId]._instated = {};\n  animation[animationId]._refObj = [];\n  animation[animationId]._objSize = {};\n\n  animation[animationId] = getLayers(elementId, animationId, newLayer, animation[animationId], 'layers', 0);\n\n  var clipPath = document.createElementNS(xmlns, 'clipPath');\n  clipPath.setAttributeNS(null, 'id', '_clip' + animationId);\n  animation[animationId].defs.prepend(clipPath);\n  var clipPathRect = document.createElementNS(xmlns, 'rect');\n  clipPathRect.setAttribute('x', 0);\n  clipPathRect.setAttribute('y', 0);\n  clipPathRect.setAttribute('width', animation[animationId].w);\n  clipPathRect.setAttribute('height', animation[animationId].h);\n  clipPath.append(clipPathRect);\n\n  newLayer.setAttributeNS(null, 'clip-path', 'url(#_clip' + animationId + ')');\n  animation[animationId]._buildDone = true;\n  animationLoading = animationLoading - 1;\n  animation[animationId]._loaded = true;\n  if (!animation[animationId]._autoplay) {\n    lottie.goToAndStop(1, '', animation[animationId]._elementId);\n  }\n  /*} catch (e) {\n\t\tconsole.error(\"Failed to load animation. \" + e);\n\t\tanimationCount = animationCount - 1;\n\t\telementObj.style.height = 0;\n\t\telementObj.style.width = 0;\n\t\telementObj.innerHTML = \"\";\n\t\tanimation.splice(animationId, 1);\n\t}*/\n}\n\nfunction getJson(src, autoplay, controls, loop, mode, style, domElement, elementNo, elementId, _autoplay, _loop) {\n  var http = new XMLHttpRequest();\n  http.open('GET', src, true);\n  http.onreadystatechange = function () {\n    if (http.readyState == 4 && http.status == 200) {\n      animationCount = animationCount + 1;\n      var currentAnimation = animationCount;\n      animation[currentAnimation] = JSON.parse(http.responseText);\n      animation[currentAnimation]._elementId = elementId;\n      buildGraph(elementId, currentAnimation, domElement, _autoplay, _loop);\n    }\n  };\n  http.send();\n}\n\nfunction processLottie(lottieElement, JSONsrc) {\n  var autoplay = '';\n  var controls = '';\n  var loop = '';\n  var mode = '';\n  var src = '';\n  var style = '';\n  var elementId = '';\n\n  if (lottieElement === undefined) {\n    var lottieElements = document.getElementsByTagName('lottie-player');\n    var i;\n    for (i = 0; i < lottieElements.length; i++) {\n      animationLoading = animationLoading + 1;\n\n      var attributes = lottieElements[i].attributes;\n      var j;\n\n      autoplay = '';\n      controls = '';\n      loop = '';\n      mode = '';\n      src = '';\n      style = '';\n      elementId = '';\n      for (j = 0; j < attributes.length; j++) {\n        switch (attributes[j].nodeName) {\n          case 'autoplay':\n            break;\n          case 'controls':\n            break;\n          case 'loop':\n            break;\n          case 'mode':\n            break;\n          case 'src':\n            src = attributes[j].nodeValue;\n            break;\n          case 'style':\n            break;\n          case 'id':\n            elementId = attributes[j].nodeValue;\n            break;\n        }\n      }\n      getJson(src, autoplay, controls, loop, mode, style, lottieElements[i], i, elementId, true, true);\n    }\n  } else {\n    animationLoading = animationLoading + 1;\n    if (!(JSONsrc === undefined) && JSONsrc.length > 0) {\n      var currentAnimation = animationCount;\n      animation[currentAnimation] = JSON.parse(JSONsrc);\n      animation[currentAnimation]._elementId = elementId;\n      buildGraph(elementId, currentAnimation, testElement, true, true);\n    } else {\n      var testElement = document.getElementById(lottieElement);\n      src = testElement.getAttribute('src');\n      elementId = testElement.getAttribute('id');\n      getJson(src, autoplay, controls, loop, mode, style, testElement, i, elementId, true, true);\n    }\n  }\n\n  if (!playStarted) {\n    playStarted = true;\n    window.requestAnimationFrame(lottiemate);\n  }\n}\n\nexports.loadAnimation = 'jlottie.loadAnimation';\nexports.goToAndStop = 'jlottie.goToAndStop';\nexports.play = 'jlottie.play';\nexports.stop = 'jlottie.stop';\nexports.destroy = 'jlottie.destroy';\n"],"names":["exports","loadAnimation","goToAndStop","play","stop","destroy"],"mappings":";;;AAi9DAA,QAAQC,cAAgB,wBACxBD,QAAQE,YAAc,sBACtBF,QAAQG,KAAO,eACfH,QAAQI,KAAO,eACfJ,QAAQK,QAAU"}